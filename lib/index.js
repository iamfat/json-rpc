import e from"hash-sum";import{nanoid as t}from"nanoid/non-secure";
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */function s(e,t,s,r){return new(s||(s=Promise))((function(i,o){function n(e){try{a(r.next(e))}catch(e){o(e)}}function c(e){try{a(r.throw(e))}catch(e){o(e)}}function a(e){var t;e.done?i(e.value):(t=e.value,t instanceof s?t:new s((function(e){e(t)}))).then(n,c)}a((r=r.apply(e,t||[])).next())}))}class r extends Error{constructor(e,t){super(e),this.code=t||0,this.message=e}toString(){return this.message}}class i{constructor(e,t){this._promises=new Map,this._callings=new Map,this._patterns=[],this._hashedFunctions=new Map,this._remoteObjects=new Map,this._remoteObjectClusters=new Map,this.extendedRPCs=[],this.send=e,this._options=Object.assign({timeout:5e3},t||{}),this.on("_.Function.call",(e,t)=>s(this,void 0,void 0,(function*(){if(this._hashedFunctions.has(e)){let s=this._hashedFunctions.get(e);return yield Promise.resolve(s(...t))}}))),this.on("_.Function.release",e=>{this._hashedFunctions.has(e)&&this._hashedFunctions.delete(e)}),this.on("_.RemoteObject.set",(e,t,s)=>{try{const r=this._remoteObjects.get(e),i=t.split("."),o=i.pop();let n=r;for(let e of i)n=Reflect.get(n,e);Reflect.set(n,o,s)}catch(e){console.debug(e)}}),this.on("_.RemoteObject.get",e=>s(this,void 0,void 0,(function*(){try{const t=this._remoteObjects.get(e);return JSON.parse(JSON.stringify(yield Promise.resolve(t)))}catch(e){console.debug(e)}}))),this.on("_.RemoteObject.apply",(e,t,r)=>s(this,void 0,void 0,(function*(){try{const s=this._remoteObjects.get(e);let i,o;"$"===t.slice(-1)?(o=t.slice(0,-1).split("."),i=!0):(o=t.split("."),i=!1);const n=o.pop();let c=s;for(let e of o)c=Reflect.get(c,e);let a=yield Promise.resolve(Reflect.apply(c[n],c,r));return i?JSON.parse(JSON.stringify(a)):this.makeRemoteObject(a,e)}catch(e){}}))),this.on("_.RemoteObject.release",e=>((this._remoteObjectClusters.get(e)||[]).map(e=>this._remoteObjects.delete(e)),this._remoteObjectClusters.delete(e),!0))}decodeNonScalars(e){const t=this,s=e=>{if(e===Object(e)){if("1.0"===e["@func"]&&Reflect.has(e,"hash"))return new Proxy(()=>{},{get(s,r){const i=String(r);return Reflect.has(s,r)?s[r]:"release"===i?()=>{t.notify("_.Function.release",[e.hash])}:void 0},apply(s,r,i){t.notify("_.Function.call",[e.hash,i])}});for(let t in e)e[t]=s(e[t])}else{if(Array.isArray(e))return e.map(e=>s(e));if(i.bufferDecode&&"string"==typeof e&&"@buf:"===e.slice(0,4))return i.bufferDecode(e.slice(5))}return e};return s(e)}encodeNonScalars(t){const s=t=>{if("function"==typeof t){let s=e(t);return this._hashedFunctions.set(s,t),{"@func":"1.0",hash:s}}if(i.isBuffer&&i.bufferEncode&&i.isBuffer(t))return"@buf:"+i.bufferEncode(t);if(Array.isArray(t))return t.map(e=>s(e));if(Object(t)===t)for(let e in t)t[e]=s(t[e]);return t};return s(t)}makeRemoteObject(e,s){const r=t();this._remoteObjects.set(r,e);const i=s||r,o=this._remoteObjectClusters.get(i)||[];return o.push(r),this._remoteObjectClusters.set(i,o),{"@remote":r}}extends(e){this.extendedRPCs.push(e)}getHandler(e){let t,s;if(this._callings.has(e))t=this._callings.get(e);else for(let{pattern:r,callback:i}of this._patterns)if(s=e.match(r),s){t=i;break}return[t,s]}receive(e){return s(this,void 0,void 0,(function*(){if("string"==typeof e)try{e=JSON.parse(e)}catch(e){return void this.sendError(new r("Parse error",-32700))}if("2.0"===e.jsonrpc){if(Reflect.has(e,"method")){let t,{method:s,params:i}=e;"$"===s.slice(-1)?(s=s.slice(0,-1),t=!0):t=!1;let[o,n]=this.getHandler(s);if(void 0===o&&this.extendedRPCs.length>0)for(let e of this.extendedRPCs)if([o,n]=e.getHandler(s),o)break;if(void 0===o)return void(e.id&&this.sendError(new r(`Method "${s}" not found`,-32601),e.id));i=this.decodeNonScalars(i),Array.isArray(i)||(i=[i]);try{let s;n&&(i=[i,n]),s=yield Promise.resolve(o(...i)),t&&(s=this.makeRemoteObject(s)),e.id&&this.sendResult(s,e.id)}catch(t){if(!(t instanceof r))throw t;this.sendError(t,e.id)}}else if(Reflect.has(e,"error")){if(e.id&&this._promises.has(e.id)){let t=this._promises.get(e.id);t.reject(e.error),clearTimeout(t.timeout),this._promises.delete(e.id)}}else if(Reflect.has(e,"result")&&e.id&&this._promises.has(e.id)){let t=this._promises.get(e.id),s=e.result;if(s&&"object"==typeof s&&Reflect.has(s,"@remote")){const e=this,t=s["@remote"],r={set(s,r,i){const o=String(r),n=s.$$baseName?`${s.$$baseName}.${o}`:o;return e.call("_.RemoteObject.set",[t,n,i]),!0},get(e,t){const s=String(t);if("then"!==s&&"$$"!==s.slice(0,1))return Reflect.has(e,t)?e[t]:(Reflect.has(e.$$cache,t)||(e.$$cache[t]=new Proxy(Object.assign(()=>{},{$$baseName:e.$$baseName?`${e.$$baseName}.${s}`:s,$$cache:{}}),r)),e.$$cache[t])},apply:(s,r,i)=>e.call("_.RemoteObject.apply",[t,s.$$baseName,i])},i={};s=new Proxy(Object.assign(()=>{},{$$cache:i,release$:()=>(Object.keys(i).forEach(e=>delete i[e]),e.call("_.RemoteObject.release",[t])),get$:()=>e.call("_.RemoteObject.get",[t])}),r)}t.resolve(s),clearTimeout(t.timeout),this._promises.delete(e.id)}}else this.sendError(new r("Parse error",-32700))}))}sendResult(e,t){const s={jsonrpc:"2.0",result:e||null};return t&&(s.id=t),this.send(s),this}sendError(e,t){const s={jsonrpc:"2.0",error:{code:e.code,message:e.message}};return t&&(s.id=t),this.send(s),this}notify(e,t={}){t=this.encodeNonScalars(t),this.send({jsonrpc:"2.0",method:e,params:t})}call(e,s={}){s=this.encodeNonScalars(s);let i=this;return new Promise((o,n)=>{let c=t(),a={id:c,jsonrpc:"2.0",method:e,params:s};i.send(a),i._promises.set(c,{resolve:o,reject:n,timeout:setTimeout(()=>{i._promises.delete(c),n(new r(`Call ${e} Timeout`,-32603))},i._options.timeout)})})}on(e,t){return"string"!=typeof e?this._patterns.push({pattern:e,callback:t}):this._callings.set(e,t),this}off(e){if("string"!=typeof e){for(let t in this._callings.keys())null!=t.match(e)&&this._callings.delete(t);let t=e.toString();this._patterns=this._patterns.filter(({pattern:e})=>e.toString()!==t)}else this._callings.has(e)&&this._callings.delete(e);return this}}i.Error=r,Object.assign(i,{isBuffer:e=>Buffer.isBuffer(e),bufferEncode:e=>e.toString("base64"),bufferDecode:e=>Buffer.from(e,"base64")});export default i;export{i as RPC,r as RPCError};
//# sourceMappingURL=index.js.map
