"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e,t=(e=require("hash-sum"))&&"object"==typeof e&&"default"in e?e.default:e,s=require("nanoid/non-secure");class r extends Error{constructor(e,t){super(e),this.code=t||0,this.message=e}toString(){return this.message}}class i{constructor(e,t){this._promises={},this._callingHandlers={},this._patterns=[],this._hashedFunctions={},this._remoteObjects={},this._remoteObjectClusters={},this.extendedRPCs=[],this.send=e,this._options=Object.assign({timeout:5e3},t||{}),this.on("_.Function.call",(e,t)=>{if(this._hashedFunctions.hasOwnProperty(e)){let s=this._hashedFunctions[e];return Promise.resolve(s(...t))}return Promise.resolve()}),this.on("_.Function.release",e=>{this._hashedFunctions.hasOwnProperty(e)&&delete this._hashedFunctions[e]}),this.on("_.RemoteObject.set",(e,t,s)=>{try{const r=this._remoteObjects[e],i=t.split("."),o=i.pop();let n=r;for(let e of i)n=Reflect.get(n,e);Reflect.set(n,o,s)}catch(e){console.debug(e)}}),this.on("_.RemoteObject.get",e=>{const t=this._remoteObjects[e];return Promise.resolve(t).then(e=>JSON.parse(JSON.stringify(e))).catch(e=>{console.debug("_.RemoteObject.get error",e)})}),this.on("_.RemoteObject.apply",(e,t,s)=>{const r=this._remoteObjects[e];let i,o;"$"===t.slice(-1)?(o=t.slice(0,-1).split("."),i=!0):(o=t.split("."),i=!1);const n=o.pop();let c=r;for(let e of o)c=Reflect.get(c,e);return Promise.resolve(Reflect.apply(c[n],c,s)).then(t=>i?JSON.parse(JSON.stringify(t)):this.makeRemoteObject(t,e))}),this.on("_.RemoteObject.release",e=>((this._remoteObjectClusters[e]||[]).map(e=>delete this._remoteObjects[e]),delete this._remoteObjectClusters[e],!0))}decodeNonScalars(e){const t=this,s=e=>{if(e===Object(e)){if("1.0"===e["@func"]&&Reflect.has(e,"hash"))return new Proxy(()=>{},{get(s,r){const i=String(r);return Reflect.has(s,r)?s[r]:"release"===i?()=>{t.notify("_.Function.release",[e.hash])}:void 0},apply(s,r,i){t.notify("_.Function.call",[e.hash,i])}});for(let t in e)e[t]=s(e[t])}else{if(Array.isArray(e))return e.map(e=>s(e));if(i.bufferDecode&&"string"==typeof e&&"@buf:"===e.slice(0,5))return i.bufferDecode(e.slice(5))}return e};return s(e)}encodeNonScalars(e){const s=e=>{if("function"==typeof e){let s=t(e);return this._hashedFunctions[s]=e,{"@func":"1.0",hash:s}}if(i.isBuffer&&i.bufferEncode&&i.isBuffer(e))return"@buf:"+i.bufferEncode(e);if(Array.isArray(e))return e.map(e=>s(e));if(Object(e)===e)for(let t in e)e[t]=s(e[t]);return e};return s(e)}makeRemoteObject(e,t){const r=s.nanoid();this._remoteObjects[r]=e;const i=t||r,o=this._remoteObjectClusters[i]||[];return o.push(r),this._remoteObjectClusters[i]=o,{"@remote":r}}extends(e){this.extendedRPCs.push(e)}getHandler(e){if(this._callingHandlers.hasOwnProperty(e)){const t=this._callingHandlers[e];return t.once&&delete this._callingHandlers[e],[t.callback]}for(let t of this._patterns){const s=e.match(t.pattern);if(s)return[t.callback,s]}return[void 0]}receive(e){if("string"==typeof e)try{e=JSON.parse(e)}catch(e){return void this.sendError(new r("Parse error",-32700))}if("2.0"===e.jsonrpc){if(Reflect.has(e,"method")){let t,s=e.method,i=e.params;"$"===s.slice(-1)?(s=s.slice(0,-1),t=!0):t=!1;let[o,n]=this.getHandler(s);if(void 0===o&&this.extendedRPCs.length>0)for(let e of this.extendedRPCs)if([o,n]=e.getHandler(s),o)break;return void 0===o?void(e.id&&this.sendError(new r(`Method "${s}" not found`,-32601),e.id)):(i=this.decodeNonScalars(i),Array.isArray(i)||(i=[i]),n&&(i=[i,n]),Promise.resolve(o(...i)).then(s=>{t&&(s=this.makeRemoteObject(s)),e.id&&this.sendResult(s,e.id)}).catch(t=>{if(!(t instanceof r))throw t;this.sendError(t,e.id)}))}if(Reflect.has(e,"error")){if(e.id&&this._promises.hasOwnProperty(e.id)){let t=this._promises[e.id];t.reject(e.error),clearTimeout(t.timeout),delete this._promises[e.id]}}else if(Reflect.has(e,"result")&&e.id&&this._promises.hasOwnProperty(e.id)){let t=this._promises[e.id],s=e.result;if(s&&"object"==typeof s&&Reflect.has(s,"@remote")){const e=this,t=s["@remote"],r={set(s,r,i){const o=String(r),n=s.$$baseName?`${s.$$baseName}.${o}`:o;return e.call("_.RemoteObject.set",[t,n,i]),!0},get(e,t){const s=String(t);if("then"!==s&&"$$"!==s.slice(0,1))return Reflect.has(e,t)?e[t]:(Reflect.has(e.$$cache,t)||(e.$$cache[t]=new Proxy(Object.assign(()=>{},{$$baseName:e.$$baseName?`${e.$$baseName}.${s}`:s,$$cache:{}}),r)),e.$$cache[t])},apply:(s,r,i)=>e.call("_.RemoteObject.apply",[t,s.$$baseName,i])},i={};s=new Proxy(Object.assign(()=>{},{$$cache:i,release$:()=>(Object.keys(i).forEach(e=>delete i[e]),e.call("_.RemoteObject.release",[t])),get$:()=>e.call("_.RemoteObject.get",[t])}),r)}t.resolve(s),clearTimeout(t.timeout),delete this._promises[e.id]}return Promise.resolve()}this.sendError(new r("Parse error",-32700))}sendResult(e,t){const s={jsonrpc:"2.0",result:e||null};return t&&(s.id=t),this.send(s),this}sendError(e,t){const s={jsonrpc:"2.0",error:{code:e.code,message:e.message}};return t&&(s.id=t),this.send(s),this}notify(e,t={}){t=this.encodeNonScalars(t),this.send({jsonrpc:"2.0",method:e,params:t})}call(e,t={}){t=this.encodeNonScalars(t);let i=this;return new Promise((o,n)=>{let c=s.nanoid(),a={id:c,jsonrpc:"2.0",method:e,params:t};i.send(a),i._promises[c]={resolve:o,reject:n,timeout:setTimeout(()=>{delete i._promises[c],n(new r(`Call ${e} Timeout`,-32603))},i._options.timeout)}})}once(e,t){return this.on(e,t,!0)}on(e,t,s=!1){return"string"!=typeof e?this._patterns.push({pattern:e,callback:t}):this._callingHandlers[e]={callback:t,once:s},this}off(e){if("string"!=typeof e){for(let t in this._callingHandlers)null!=t.match(e)&&delete this._callingHandlers[t];let t=e.toString();this._patterns=this._patterns.filter(e=>e.pattern.toString()!==t)}else delete this._callingHandlers[e];return this}}i.Error=r,Object.assign(i,{isBuffer:e=>Buffer.isBuffer(e),bufferEncode:e=>e.toString("base64"),bufferDecode:e=>Buffer.from(e,"base64")}),exports.RPC=i,exports.RPCError=r,exports.default=i;
//# sourceMappingURL=index.js.map
